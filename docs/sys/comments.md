# Code Commenting Patterns

Standards for commenting TypeScript files in the FloatPrompt build system.

## Why This Matters

1. **AI consumption** — Clear comments help AI understand code structure
2. **Consistency** — Same patterns across all files
3. **Onboarding** — New sessions can quickly understand conventions
4. **Maintenance** — Easier to update when patterns are predictable

## File Structure

Every TypeScript file should follow this structure:

```typescript
import { z } from "zod";

/**
 * Component Name
 * Format: what format/structure this defines
 * Use: when/why to use this
 *
 * Design principles:
 * 1. First principle — brief explanation
 * 2. Second principle — brief explanation
 * 3. Third principle — brief explanation
 * 4. Fourth principle — brief explanation
 */

export const Something = z.object({
  // Section name (context about this group)
  field: z.string(),                     // what it is
  field: z.string(),                     // what it is

  // Section name (context about this group)
  field: z.string(),                     // what it is
});

// Type exports
export type Something = z.infer<typeof SomethingSchema>;
```

## Docblock

Every file starts with a docblock:

```typescript
/**
 * Component Name
 * Format: <fp><json>...</json><md>...</md></fp>
 * Use: Tools that modify AI behavior
 *
 * Design principles:
 * 1. ...
 * 2. ...
 * 3. ...
 * 4. ...
 */
```

**Required elements:**
- **Name** — What this component is
- **Format** — What structure it defines (if applicable)
- **Use** — When/why to use it
- **Design principles** — 4 bullet points explaining the thinking

## Section Comments

Group related fields with section comments:

```typescript
export const Schema = z.object({
  // Terrain awareness (human-written or AI-assisted)
  title: z.string(),
  type: z.string(),

  // Attribution (auto-generated by build system)
  created: z.string(),
  human_author: z.string(),

  // Optional depth (add when needed)
  human_context: z.string().optional(),
});
```

**Format:** `// Section name (brief context)`

## Inline Comments

Every field gets an inline comment:

```typescript
title: z.string(),                     // what is this
type: z.string(),                      // what kind (nav, context, decisions...)
status: z.string(),                    // is it current (current, draft, archived...)
```

**Rules:**
- Align at column 42 (or consistent column for the file)
- Brief — what the field is, not documentation
- Include examples in parentheses when helpful

## Type Exports

Group type exports at the end:

```typescript
// Type exports
export type FloatPromptJson = z.infer<typeof FloatPromptJsonSchema>;
export type Meta = z.infer<typeof MetaSchema>;
export type Human = z.infer<typeof HumanSchema>;
```

## Removed Fields

When a field is intentionally removed, document why:

```typescript
export const MetaSchema = z.object({
  title: z.string(),
  id: z.string(),
  type: z.enum(["system", "custom"]),
  // format: removed — system knows it's floatprompt
  // version: removed — system/package.json owns versioning
});
```

## Examples

### Schema File (floatprompt.ts)

```typescript
import { z } from "zod";

/**
 * FloatPrompt Schema
 * Format: <fp><json>{ ... }</json><md>...</md></fp>
 * Use: Tools that modify AI behavior
 *
 * Design principles:
 * 1. Structured JSON — 5 top-level keys, predictable shape
 * 2. Minimal required fields — just what's needed for identity and behavior
 * 3. Flexible requirements — AI's playground for tool-specific logic
 * 4. Type discriminator — system vs custom determines markdown validation
 */

export const MetaSchema = z.object({
  // Identity (required)
  title: z.string(),                     // display name
  id: z.string(),                        // identifier (kebab-case)
  type: z.enum(["system", "custom"]),    // determines markdown validation strictness
});
```

### Tool Config File

```typescript
/**
 * Float Sync Tool
 * Format: Minimal FloatPrompt (tier 3 — chained tool)
 * Use: Compile to .float/tools/float-sync.md
 *
 * Design principles:
 * 1. Minimal JSON — just routing info (id, title, triggers, checks, outputs)
 * 2. Process in markdown — the one thing that needs prose
 * 3. Inherits from boot.md — patterns defined there
 * 4. No STOP — boot.md already set focus
 */

import type { FloatPromptJson } from "../schema/floatprompt";

export const json: FloatPromptJson = {
  id: "float-sync",
  title: "/float sync",
  triggers: [...],
  checks: [...],
  outputs: [...],
};

export const markdown = `# /float sync
...process steps...
`;

export const compile = () => `<fp><json>...</json><md>...</md></fp>`;
```

---

*Follow these patterns for all new TypeScript files in src/*
