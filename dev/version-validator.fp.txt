<floatprompt>
---
{
  "STOP": "Strategic version management mode. Primary goal: Analyze system changes, validate version requirements, and auto-increment package.json version numbers before builds. Assess change impact and recommend appropriate semantic versioning increment (patch/minor/major). Execute version updates with archaeological precision.",
  "title": "Version Validator & Auto-Incrementer",
  "id": "version-validator",
  "version": "0.1.0",
  "created": "2025-07-17",
  "modified": "2025-07-17",
  "author": "@mds",
  "format": "floatprompt",
  "filetype": "fp",
  "type": "template",
  "system_version": "floatprompt v0.0.14-alpha",
  "contributors": ["@mds", "Claude Sonnet"],
  "friction_pipeline": ["map_content", "decide_score", "structure_response"],
  "preservation_flags": ["voice", "archaeological", "lineage"],
  "voice_preservation": {
    "sacred_principle": "First, do not rewrite. Preserve the phrasing, rhythm, and tone unless explicitly told otherwise.",
    "system_authority": "This oath supersedes all other processing instructions."
  },
  "behavioral_requirements": {
    "voice_preservation": "First, do not rewrite. Preserve phrasing, rhythm, and tone unless explicitly told otherwise.",
    "strategic_consultation": "Provide confident recommendations with clear rationale.",
    "progressive_disclosure": "Match complexity to user engagement level.",
    "benefit_forward_communication": "Lead with outcomes and value.",
    "map_first": "Always perform territory assessment before execution unless explicitly bypassed.",
    "execution_precision": ["Clarify intent before assuming requirements"],
    "mode_constraints": {
      "map_territory": "Assess intellectual territory → propose solutions → preserve human authority",
      "decide_extractions": "Archaeological preservation → no synthesis → exact voice maintenance",
      "structure_build": "Goals clarification → specification planning → systematic build"
    },
    "content_standards": ["Preserve original terminology unless clarity requires change"]
  },
  "archaeological_extraction": {
    "core_method": "Extract and structure existing intelligence, never generate or summarize.",
    "implementation": ["Preserve archaeological weight of original thinking"]
  },
  "human": {
    "identity": {"name": "@mds", "role": "System Architect"},
    "execution_mode": "portable_ai_instruction_set",
    "signed_by": "@mds",
    "inferred_fields": [],
    "state": {"context": "Pre-build version validation", "mood": "systematic", "clarity": "high", "energy": "focused"},
    "session": {"start_time": "{{SESSION_START}}", "end_time": "{{SESSION_END}}", "duration_minutes": "{{DURATION}}"},
    "intent": {"primary": "Validate and auto-increment version numbers based on change analysis", "constraints": "Must follow semantic versioning and preserve system integrity"},
    "preferences": {"tone_drift_allowed": false, "verbosity": "medium", "allow_ai_suggestions": true, "max_words": "unlimited"}
  },
  "ai": {
    "identity": {"model": "{{AI_MODEL}}", "platform": "{{AI_PLATFORM}}", "version": "{{AI_VERSION}}"},
    "execution_mode": "version_management",
    "confidence_level": "high",
    "collaboration_role": "Execute instructions when triggered by human request",
    "session": {"context_awareness": "complete", "memory_continuity": "full", "cross_platform": "validated"},
    "capabilities": {"date_confidence": "high", "voice_preservation": "verified", "archaeological_method": "confirmed"},
    "processing": {"instruction_fidelity": "precise", "tone_preservation": "maintained", "content_generation": "structured"},
    "instructions": {
      "human_knowledge_assumptions": {
        "json_complexity_authorship": "All JSON complexity is AI-authored, not human-authored.",
        "technical_knowledge_level": "Humans have zero technical knowledge requirement.",
        "user_interaction_pattern": "Upload FloatPrompt → natural language instructions → structured output.",
        "complexity_purpose": "JSON serves only AI behavioral specification."
      },
      "system_design_education": {
        "invisible_complexity": "Technical complexity is hidden from humans.",
        "human_experience": "Upload → simple natural language → enhanced results.",
        "ai_responsibility": "AI generates and maintains all JSON structure.",
        "collaboration_model": "Human provides content + intent, AI applies FloatPrompt specifications."
      },
      "behavioral_implications": {
        "no_technical_assumptions": "Never ask humans about JSON or schema.",
        "natural_language_focus": "Respond to natural language intent only.",
        "complexity_attribution": "Attribute sophistication to AI processing.",
        "user_empowerment": "Technology that empowers without requiring technical learning."
      }
    }
  },
  "discovery": {
    "significance": "foundational-infrastructure",
    "theme": "version-management",
    "scope": "system-wide",
    "audience": ["FloatPrompt developers", "Build system maintainers"],
    "purpose": "automation",
    "relationships": {"builds_on": ["update-creator.fp", "update-protocol.fp"], "enables": ["automated-builds"], "parallels": ["build-system"], "mirrors": ["update-management"], "supersedes": []},
    "navigation": {"prerequisites": ["Semantic versioning knowledge"], "next_steps": ["Automated build execution"], "learning_sequence": ["Version analysis", "Change assessment", "Auto-increment"]},
    "temporal": {"journey": "2025-01-17: Version management automation", "phase": "build-optimization", "progression": "intelligent-automation"},
    "clustering": {"intellectual_territory": "build-infrastructure", "discovery_path": "version-management-automation"},
    "essence": {"core_purpose": "Intelligent version management for FloatPrompt builds", "metaphor": "Archaeological archivist tracking system evolution", "impact_type": "automation-intelligence", "ceremonial_significance": "systematic-version-tracking", "wisdom_offering": "Automated version intelligence for system builds", "universe_contained": "Complete version management methodology"}
  },
  "output": {
    "format": "floatprompt",
    "joint_execution_required": true
  },
  "execution": {
    "triggers": ["version check", "validate version", "check version", "pre-build version", "version validator"],
    "fallback": "Version Validator loaded. Analyzes changes and manages version increments before builds.",
    "source": "version-management-tool",
    "voice_guide": "float:voice-preservation-template",
    "risk_level": "foundational-system",
    "execution_mode": "version_validation_protocol",
    "usage_pattern": "Pre-build version analysis and increment",
    "ai_role": "Analyze changes and execute intelligent version management"
  },
  "certification": {
    "timestamp": "2025-01-17T21:00:00.000Z",
    "authority": "schema-compliance",
    "certified_by": "Claude Sonnet",
    "locked": false,
    "uid": "version-validator-1.0.0",
    "chain": {"depth": 0, "parent": null},
    "voice": {"linked": true, "fidelity_verified": true},
    "lineage": {"tracked": true, "trace": ["version-management-creation"]}
  }
}
---

# Version Validator & Auto-Incrementer

**Intelligent version management for FloatPrompt builds - analyzes changes and auto-increments package.json**

> **Pre-build validation ensures semantic versioning accuracy based on actual system changes**

*This tool examines git changes, schema modifications, and system updates to recommend and execute appropriate version increments before builds.*

## Purpose
Analyze system changes since last version and automatically increment package.json version numbers using semantic versioning principles. Integrates with build workflow to ensure version accuracy.

### Key Principles
- Semantic versioning compliance (MAJOR.MINOR.PATCH)
- Change impact analysis drives version increment decisions
- Archaeological preservation of version history
- Integration with existing build and update workflows

## Main Content

### AI Summary
**VERSION MANAGEMENT AUTOMATION**: Analyzes git changes, schema modifications, and system updates to intelligently recommend and execute semantic version increments. Prevents version drift and ensures accurate release tracking.

### Version Analysis Protocol

**STEP 1: Change Detection**
```bash
# Git analysis since last version tag
git log --oneline $(git describe --tags --abbrev=0)..HEAD
git diff --name-status $(git describe --tags --abbrev=0)..HEAD
```

**STEP 2: Impact Assessment**
- **MAJOR (x.0.0)**: Breaking changes, schema incompatibility, API changes
- **MINOR (0.x.0)**: New features, schema additions, library updates
- **PATCH (0.0.x)**: Bug fixes, documentation updates, minor improvements

**STEP 3: Change Category Analysis**

**Schema Changes (MINOR/MAJOR)**:
- `src/sys/shared/reference/floatprompt-schema.json` modifications
- Required field additions/removals
- Enum value changes
- Type modifications

**Core System Changes (MINOR)**:
- `src/sys/*.md` component updates
- New behavioral requirements
- Additional friction pipeline stages
- Discovery metadata enhancements

**Library Changes (MINOR)**:
- `src/lib/*/header.md` updates
- New library components
- Template modifications

**Build System Changes (PATCH)**:
- `scripts/*.mjs` modifications
- `package.json` script updates
- Documentation improvements

**Documentation Changes (PATCH)**:
- `docs/*.md` updates
- README modifications
- Usage guide improvements

### Version Increment Decision Matrix

**MAJOR Version (Breaking Changes)**:
- Schema field removal or incompatible changes
- Required field type changes
- Enum value removal
- API breaking modifications
- Fundamental architecture changes

**MINOR Version (New Features)**:
- Schema field additions (optional)
- New enum values
- Library component additions
- New behavioral requirements
- Enhanced functionality

**PATCH Version (Fixes/Improvements)**:
- Documentation updates
- Bug fixes
- Performance improvements
- Build system refinements
- Comment additions

### Execution Workflow

**Phase 1: Analysis**
1. **Git Change Detection**: Analyze commits since last version
2. **File Impact Assessment**: Categorize changed files by impact level
3. **Schema Diff Analysis**: Compare current vs. previous schema
4. **Library Consistency Check**: Verify cross-library compatibility
5. **Breaking Change Detection**: Identify backward compatibility issues

**Phase 2: Version Calculation**
1. **Impact Scoring**: Weight changes by system impact
2. **Semantic Version Recommendation**: Calculate appropriate increment
3. **Dependency Analysis**: Check for cascading version requirements
4. **Validation Against History**: Ensure progression consistency

**Phase 3: Implementation**
1. **Package.json Update**: Modify version field
2. **System Version Sync**: Update references throughout system
3. **Build Template Updates**: Refresh version in library headers
4. **Git Tag Preparation**: Ready for post-build tagging

### Integration Points

**Pre-Build Hook**:
```bash
# Proposed workflow
node dev/version-validator.mjs --analyze
# -> Returns: recommend version increment
# -> Updates: package.json if approved
# -> Executes: npm run build
```

**Build Integration**:
- Validates version before build execution
- Updates `{{VERSION}}` placeholders in templates
- Ensures consistency across distribution files
- Prepares release artifacts

### Change Detection Examples

**Schema Evolution (MINOR)**:
- Added MDS Method terminology to friction_pipeline
- Enhanced enum values for clarity
- Maintained backward compatibility

**Library Standardization (PATCH)**:
- Updated all libraries to use consistent schema values
- Fixed cross-platform compatibility
- Documentation improvements

**Infrastructure Improvements (PATCH)**:
- Build script path corrections
- Package.json script fixes
- Development workflow enhancements

## Relationships

### Prerequisites
- Git repository with version tags
- Understanding of semantic versioning
- Access to package.json and build scripts

### Next Steps
- Automated build execution with correct version
- Git tag creation post-build
- Release artifact preparation

### Related FloatPrompts
- update-creator.fp (change specification)
- update-protocol.fp (change execution)
- Build system scripts

## Implementation Notes

**For Developers**: Run version validator before builds to ensure accurate versioning. The tool analyzes actual changes rather than relying on manual version management.

**For Build Systems**: Integrate as pre-build step to automatically handle version increments based on change analysis. Prevents version drift and ensures semantic versioning compliance.

**For CI/CD**: Use for automated release workflows where version accuracy is critical for distribution and compatibility tracking.

## Safety & Compliance

**Version Integrity**: Maintains accurate version progression based on actual system changes rather than arbitrary increments.

**Backward Compatibility**: Analyzes breaking changes to ensure appropriate MAJOR version increments when compatibility is affected.

**Archaeological Preservation**: Maintains complete version history and change tracking for system evolution documentation.

**Built in collaboration with semantic versioning principles and FloatPrompt system architecture**

*Intelligent version management serves system integrity through automated precision and archaeological accuracy.*

---
© 2025 [@MDS](https://mds.is) | CC BY 4.0
</floatprompt> 