# FloatPrompt Runtime Mode

> **Status:** Specification document for adding runtime markdown extraction to FloatPrompt.

---

## Where This Fits

FloatPrompt's vision defines three layers:

| Layer | Model | What Happens |
|-------|-------|--------------|
| **Layer 1: Mechanical** | Build-time | `npx floatprompt generate ./dist` — static .md files |
| **Layer 2: AI Enrichment** | Build-time + AI | Same, with AI polish via user's API key |
| **Layer 3: Hosted Build Service** | FloatPrompt servers | AI enrichment as a service |

**This document defines Layer 1b: Runtime Mode** — the same mechanical extraction, delivered at request-time instead of build-time.

```
Layer 1:  Build-time static .md files     → Static sites (Hugo, Jekyll, Next.js export)
Layer 1b: Request-time dynamic .md URLs   → SSR sites (Next.js SSR, Remix, SvelteKit)
```

**Why it matters:** The PRD notes "build-time covers 80%+ of use cases." Runtime mode serves the other 20% — modern SSR sites that can't use static export because they have API routes, authentication, or dynamic rendering.

**Same philosophy:**
- Same core pipeline (`FloatPrompt.extract()`)
- Same output format (markdown with frontmatter)
- Same URL pattern (`/page` → `/page.md`)
- Self-hosted on user's domain
- No AI required

---

## Shift Nudge Integration Example

This section provides a complete, copy-paste implementation for Shift Nudge specifically.

### Install

```bash
npm install floatprompt
```

### middleware.ts (project root)

```typescript
import { createFloatMiddleware } from 'floatprompt/next-dynamic'

export const middleware = createFloatMiddleware({
  exclude: [
    // API routes
    '/api/*',

    // Next.js internals
    '/_next/*',

    // Sensitive forms
    '/apply',           // Application form with personal info
    '/join',            // Checkout/payment flow
    '/contact',         // Contact form

    // Post-purchase / authenticated
    '/welcome/*',       // Post-purchase onboarding
    '/team/*',          // Team-specific pages

    // Internal / test
    '/test/*',          // Test pages
    '/generate',        // Internal tool
    '/expired',         // Expired link page
  ],
})

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|assets|fonts|.*\\.(?:svg|png|jpg|jpeg|gif|webp|ico)$).*)',
  ],
}
```

### src/app/api/float/route.ts

```typescript
import { createFloatHandler } from 'floatprompt/next-dynamic'

export const GET = createFloatHandler({
  baseUrl: 'https://shiftnudge.com',
  cacheControl: 'public, s-maxage=3600, stale-while-revalidate=86400',
})

// Edge runtime for lower latency
export const runtime = 'edge'
```

### Expected Results

```
shiftnudge.com/                  → HTML
shiftnudge.com/index.md          → Markdown (homepage)
shiftnudge.com/curriculum.md     → Markdown
shiftnudge.com/faq.md            → Markdown
shiftnudge.com/reviews.md        → Markdown
shiftnudge.com/mds.md            → Markdown (founder page)
shiftnudge.com/schedules/8.md    → Markdown (dynamic route)
shiftnudge.com/apply.md          → 404 (excluded)
shiftnudge.com/join.md           → 404 (excluded)
```

### Shift Nudge-Specific Considerations

**Dynamic components:** Components like `<EnrollmentToggle>` render different content based on enrollment state (open/closed). The markdown will reflect the server-rendered state at request time. This is correct behavior — AI agents get the current state.

**JSON-LD schemas:** Shift Nudge pages include rich JSON-LD (Course, Organization, Person schemas). These are extracted and included in markdown frontmatter by default. Set `includeSchema: false` if you prefer cleaner output.

**Lazy-loaded content:** Components using `dynamic()` imports or `LazyMosaic` are server-rendered, so their content is included in the markdown extraction.

**Assets path:** The matcher excludes `/assets/*` and `/fonts/*` to prevent intercepting static files.

### Complete FloatPrompt Setup for Shift Nudge

For full FloatPrompt compliance, SSR sites need more than just `/page.md` routes. Here's the complete setup:

**1. Runtime `.md` extraction** (this document)
```
/curriculum.md  → Dynamic extraction
/faq.md         → Dynamic extraction
```

**2. Static `llms.txt`** (site index)
```typescript
// src/app/llms.txt/route.ts
export async function GET() {
  const content = `# Shift Nudge

> Interface design training course by Matt D. Smith

## Pages
- [Home](/index.md): Course overview and enrollment
- [Curriculum](/curriculum.md): 85 lessons across 16 modules
- [FAQ](/faq.md): Frequently asked questions
- [Reviews](/reviews.md): Student testimonials
- [About MDS](/mds.md): About the instructor

## Full Content
Complete markdown: [/llms-full.txt](/llms-full.txt)

---
Generated by FloatPrompt (runtime mode)
`
  return new Response(content, {
    headers: {
      'Content-Type': 'text/plain; charset=utf-8',
      'Cache-Control': 'public, s-maxage=86400'
    }
  })
}
```

**2b. Dynamic `llms-full.txt`** (concatenates all .md content)
```typescript
// src/app/llms-full.txt/route.ts
import { NextRequest } from 'next/server'

const PAGES = ['/', '/curriculum', '/faq', '/reviews', '/mds']

export async function GET(request: NextRequest) {
  const origin = request.nextUrl.origin
  const sections: string[] = []

  for (const path of PAGES) {
    try {
      // Fetch markdown for each page
      const mdUrl = `${origin}/api/float?path=${encodeURIComponent(path)}`
      const res = await fetch(mdUrl, {
        headers: { 'x-floatprompt-internal': '1' }
      })
      if (res.ok) {
        const md = await res.text()
        sections.push(`\n\n---\n\n${md}`)
      }
    } catch {
      // Skip failed pages
    }
  }

  const content = `# Shift Nudge — Complete Content\n\nGenerated: ${new Date().toISOString()}\n${sections.join('')}`

  return new Response(content, {
    headers: {
      'Content-Type': 'text/plain; charset=utf-8',
      'Cache-Control': 'public, s-maxage=3600'
    }
  })
}
```

**3. `/float/` dashboard page** (optional)
```typescript
// src/app/float/page.tsx
export default function FloatDashboard() {
  const pages = [
    { title: 'Home', path: '/index.md' },
    { title: 'Curriculum', path: '/curriculum.md' },
    { title: 'FAQ', path: '/faq.md' },
    { title: 'Reviews', path: '/reviews.md' },
    // ...
  ]

  return (
    <main>
      <h1>Shift Nudge — AI Context</h1>
      <p>This site is AI-readable. Add .md to any page URL.</p>
      <ul>
        {pages.map(p => (
          <li key={p.path}>
            <a href={p.path}>{p.title}</a>
          </li>
        ))}
      </ul>
      <p><a href="/llms-full.txt">Download all content</a></p>
    </main>
  )
}
```

**Result:** Full FloatPrompt compliance for an SSR site:
```
shiftnudge.com/llms.txt       → Site index
shiftnudge.com/llms-full.txt  → All content
shiftnudge.com/float/         → Human dashboard
shiftnudge.com/*.md           → Per-page markdown
```

---

## Problem Statement

FloatPrompt currently operates as a **build-time CLI tool** that processes static HTML files from a directory. This architecture excludes server-rendered sites (Next.js SSR, Remix, SvelteKit) which represent the majority of modern React marketing sites.

### What's a "Standard React Marketing Site"?

Most professional marketing sites built in the last 3-4 years follow this pattern:

- **Framework:** Next.js with App Router (or Remix, SvelteKit)
- **Rendering:** Server-side rendering (SSR) or hybrid
- **API routes:** Built-in backend for forms, payments, CRM integrations
- **Deployment:** Vercel, Netlify, or similar serverless platforms
- **No static export:** Can't use `output: 'export'` because it breaks API routes

Examples: Shift Nudge, most SaaS marketing sites, course platforms, e-commerce storefronts.

This is different from **static sites** (Hugo, Jekyll, Gatsby) where all HTML is generated at build time.

### Current Architecture (Build-Time Only)

```
npm run build
     ↓
HTML files written to ./out/
     ↓
npx floatprompt ./out
     ↓
.md files written alongside HTML
```

**Limitation:** Requires `output: 'export'` in Next.js, which breaks API routes and dynamic rendering.

### Existing Integrations vs This Document

| Integration | Import | Use Case |
|-------------|--------|----------|
| `floatprompt/next` | `withFloatPrompt()` | Static export sites (`output: 'export'`) |
| `floatprompt/next-dynamic` | `createFloatMiddleware()` | SSR sites (this document) |

**They're mutually exclusive.** Use `/next` if you can static export. Use `/next-dynamic` if you can't.

### Target Architecture (Request-Time)

```
Request: /curriculum.md
     ↓
Middleware intercepts *.md
     ↓
API route fetches /curriculum HTML
     ↓
FloatPrompt.extract(html) runs
     ↓
Response: text/markdown
```

---

## Solution Overview

Add a new export `floatprompt/next-dynamic` that provides:

1. **Middleware factory** — Intercepts `*.md` requests
2. **API route handler** — Fetches HTML, extracts markdown, returns response

The core `FloatPrompt.extract()` function already accepts HTML strings and returns markdown. No changes needed to core extraction logic.

---

## Implementation

### File: `src/integrations/next-dynamic.ts`

```typescript
/**
 * FloatPrompt Dynamic Mode for Next.js
 *
 * Enables [url].md pattern for server-rendered Next.js sites.
 *
 * @example
 * ```typescript
 * // middleware.ts
 * import { floatMiddleware } from 'floatprompt/next-dynamic'
 * export const middleware = floatMiddleware
 * export const config = { matcher: ['/((?!_next|api).*)'] }
 *
 * // app/api/float/route.ts
 * import { createFloatHandler } from 'floatprompt/next-dynamic'
 * export const GET = createFloatHandler()
 * ```
 */

import { NextRequest, NextResponse } from 'next/server'
import { FloatPrompt } from '../index.js'

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export interface FloatDynamicConfig {
  /**
   * Base URL for the site (used in frontmatter)
   * @default Inferred from request
   */
  baseUrl?: string

  /**
   * URL path patterns to exclude from .md processing
   * Supports exact paths ('/admin') and prefix patterns ('/api/*')
   * @default ['/api/*', '/_next/*', '/static/*']
   */
  exclude?: string[]

  /**
   * API route path for the float handler
   * Must match where you place the route.ts file
   * @default '/api/float'
   */
  apiRoute?: string

  /**
   * Cache-Control header value for markdown responses
   * @default 'public, s-maxage=3600, stale-while-revalidate=86400'
   */
  cacheControl?: string

  /**
   * Content-Type header for markdown responses
   * Use 'text/plain' for broader client compatibility
   * @default 'text/markdown; charset=utf-8'
   */
  contentType?: string

  /**
   * Include JSON-LD schema in markdown frontmatter
   * @default true
   */
  includeSchema?: boolean

  /**
   * Custom fetch function for retrieving HTML
   * Use this to handle authentication, custom headers, or non-HTTP sources
   * @default Internal fetch with cookie forwarding
   */
  fetchHtml?: (url: string, request: NextRequest) => Promise<string | null>
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/**
 * Check if a path matches an exclusion pattern
 * Supports exact match ('/admin') and prefix match ('/api/*')
 */
function isExcluded(pathname: string, patterns: string[]): boolean {
  for (const pattern of patterns) {
    if (pattern.endsWith('/*')) {
      // Prefix match: '/api/*' matches '/api/anything'
      const prefix = pattern.slice(0, -1) // Remove '*', keep '/'
      if (pathname.startsWith(prefix)) return true
    } else {
      // Exact match or prefix without wildcard
      if (pathname === pattern || pathname.startsWith(pattern + '/')) return true
    }
  }
  return false
}

/**
 * Normalize a .md path to its HTML equivalent
 * - /about.md → /about
 * - /index.md → /
 * - /.md → /
 * - /blog/post.md → /blog/post
 * - /about/.md → /about
 */
function mdPathToHtmlPath(pathname: string): string {
  // Remove .md extension
  let htmlPath = pathname.slice(0, -3)

  // Handle edge cases
  if (htmlPath === '' || htmlPath === '/index' || htmlPath === '/.') {
    return '/'
  }

  // Handle trailing slash before .md: /about/.md → /about
  if (htmlPath.endsWith('/.')) {
    htmlPath = htmlPath.slice(0, -2)
  }

  // Handle /index at end of path: /blog/index → /blog
  if (htmlPath.endsWith('/index')) {
    htmlPath = htmlPath.slice(0, -6) || '/'
  }

  return htmlPath
}

// ---------------------------------------------------------------------------
// Internal Request Header
// ---------------------------------------------------------------------------

const INTERNAL_HEADER = 'x-floatprompt-internal'

// ---------------------------------------------------------------------------
// Middleware
// ---------------------------------------------------------------------------

/**
 * Create middleware that intercepts *.md requests
 *
 * Rewrites /page.md → /api/float?path=/page
 */
export function createFloatMiddleware(config: FloatDynamicConfig = {}) {
  const excludePatterns = config.exclude ?? ['/api/*', '/_next/*', '/static/*', '/favicon.ico']
  const apiRoute = config.apiRoute ?? '/api/float'

  return function floatMiddleware(request: NextRequest): NextResponse {
    const { pathname } = request.nextUrl

    // Skip internal requests (prevents infinite loops)
    if (request.headers.get(INTERNAL_HEADER) === '1') {
      return NextResponse.next()
    }

    // Skip excluded paths
    if (isExcluded(pathname, excludePatterns)) {
      return NextResponse.next()
    }

    // Intercept .md requests
    if (pathname.endsWith('.md')) {
      const htmlPath = mdPathToHtmlPath(pathname)

      // Rewrite to API route (configurable path)
      const url = request.nextUrl.clone()
      url.pathname = apiRoute
      url.searchParams.set('path', htmlPath)

      return NextResponse.rewrite(url)
    }

    return NextResponse.next()
  }
}

/**
 * Pre-configured middleware with sensible defaults
 * Use createFloatMiddleware() if you need custom configuration
 */
export const floatMiddleware = createFloatMiddleware()

// ---------------------------------------------------------------------------
// API Route Handler
// ---------------------------------------------------------------------------

/**
 * Check if HTML has noindex robots meta tag
 */
function hasNoIndexMeta(html: string): boolean {
  // Check for <meta name="robots" content="noindex">
  const robotsMatch = html.match(/<meta[^>]+name=["']robots["'][^>]+content=["']([^"']+)["']/i)
  if (robotsMatch && robotsMatch[1].toLowerCase().includes('noindex')) {
    return true
  }
  // Also check reverse attribute order
  const robotsMatchAlt = html.match(/<meta[^>]+content=["']([^"']+)["'][^>]+name=["']robots["']/i)
  if (robotsMatchAlt && robotsMatchAlt[1].toLowerCase().includes('noindex')) {
    return true
  }
  return false
}

/**
 * Default HTML fetcher that forwards cookies and handles internal requests
 */
async function defaultFetchHtml(
  url: string,
  request: NextRequest
): Promise<string | null> {
  try {
    const response = await fetch(url, {
      headers: {
        // Forward cookies for authenticated pages
        'Cookie': request.headers.get('cookie') || '',
        // Forward user agent
        'User-Agent': request.headers.get('user-agent') || 'FloatPrompt/1.0',
        'Accept': 'text/html',
        // Mark as internal to prevent middleware loops
        [INTERNAL_HEADER]: '1',
      },
      // Don't follow redirects automatically - let us handle them
      redirect: 'manual',
    })

    // Handle redirects
    if (response.status >= 300 && response.status < 400) {
      const location = response.headers.get('location')
      if (location) {
        // Could recursively fetch, but for safety just return null
        // User should request the canonical .md URL
        return null
      }
    }

    if (!response.ok) {
      return null
    }

    const html = await response.text()

    // Respect noindex meta tag — don't expose pages marked as noindex
    if (hasNoIndexMeta(html)) {
      return null
    }

    return html
  } catch {
    return null
  }
}

/**
 * Create API route handler that extracts and returns markdown
 *
 * Fetches the HTML page, runs extraction, returns markdown.
 */
export function createFloatHandler(config: FloatDynamicConfig = {}) {
  const {
    cacheControl = 'public, s-maxage=3600, stale-while-revalidate=86400',
    contentType = 'text/markdown; charset=utf-8',
    includeSchema = true,
    fetchHtml = defaultFetchHtml,
  } = config

  return async function floatHandler(request: NextRequest): Promise<Response> {
    const path = request.nextUrl.searchParams.get('path')

    if (!path) {
      return new Response('Missing path parameter', {
        status: 400,
        headers: { 'Content-Type': 'text/plain' },
      })
    }

    // Determine origin for fetching
    // In production, use configured baseUrl or request origin
    // On Vercel, request.nextUrl.origin works correctly
    const origin = config.baseUrl || request.nextUrl.origin
    const htmlUrl = new URL(path, origin).toString()

    try {
      // Fetch HTML
      const html = await fetchHtml(htmlUrl, request)

      if (!html) {
        return new Response(`Page not found: ${path}`, {
          status: 404,
          headers: { 'Content-Type': 'text/plain' },
        })
      }

      // Extract markdown using core FloatPrompt
      const result = FloatPrompt.extract(html, {
        url: path,
        baseUrl: origin,
        includeSchema,
      })

      if (!result || !result.markdown) {
        return new Response(`Could not extract content from: ${path}`, {
          status: 422,
          headers: { 'Content-Type': 'text/plain' },
        })
      }

      // Return markdown
      return new Response(result.markdown, {
        status: 200,
        headers: {
          'Content-Type': contentType,
          'Cache-Control': cacheControl,
          // Include metadata in headers for programmatic access
          'X-FloatPrompt-Title': encodeURIComponent(result.title || ''),
          'X-FloatPrompt-Source': encodeURIComponent(path),
        },
      })
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error'
      console.error(`FloatPrompt extraction failed for ${path}:`, message)

      return new Response(`Extraction failed: ${message}`, {
        status: 500,
        headers: { 'Content-Type': 'text/plain' },
      })
    }
  }
}

/**
 * Pre-configured handler with sensible defaults
 * Use createFloatHandler() if you need custom configuration
 */
export const floatHandler = createFloatHandler()

// ---------------------------------------------------------------------------
// Middleware Composition Helper
// ---------------------------------------------------------------------------

/**
 * Compose FloatPrompt middleware with your existing middleware
 *
 * @example
 * ```typescript
 * import { composeWithFloat } from 'floatprompt/next-dynamic'
 *
 * function myMiddleware(request: NextRequest) {
 *   // Your existing logic
 *   return NextResponse.next()
 * }
 *
 * export const middleware = composeWithFloat(myMiddleware)
 * ```
 */
export function composeWithFloat(
  userMiddleware: (request: NextRequest) => NextResponse | Response | Promise<NextResponse | Response>,
  config: FloatDynamicConfig = {}
) {
  const floatMw = createFloatMiddleware(config)

  return async function composedMiddleware(request: NextRequest): Promise<NextResponse | Response> {
    // Check for .md requests first
    const { pathname } = request.nextUrl
    if (pathname.endsWith('.md') && !request.headers.get(INTERNAL_HEADER)) {
      const floatResult = floatMw(request)
      // If float middleware rewrote the request, use that
      if (floatResult.headers.get('x-middleware-rewrite')) {
        return floatResult
      }
    }

    // Otherwise, run user middleware
    return userMiddleware(request)
  }
}
```

---

## Package.json Changes

### Add new export

```json
{
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./next": {
      "import": "./dist/integrations/next.js",
      "types": "./dist/integrations/next.d.ts"
    },
    "./next-dynamic": {
      "import": "./dist/integrations/next-dynamic.js",
      "types": "./dist/integrations/next-dynamic.d.ts"
    },
    "./astro": {
      "import": "./dist/integrations/astro.js",
      "types": "./dist/integrations/astro.d.ts"
    },
    "./widget": {
      "import": "./dist/widget/index.js",
      "types": "./dist/widget/index.d.ts"
    },
    "./react": {
      "import": "./dist/widget/react.js",
      "types": "./dist/widget/react.d.ts"
    }
  }
}
```

### Add Next.js as optional peer dependency

```json
{
  "peerDependencies": {
    "react": ">=17.0.0",
    "next": ">=13.0.0"
  },
  "peerDependenciesMeta": {
    "react": { "optional": true },
    "next": { "optional": true }
  }
}
```

---

## Usage

### Basic Setup (2 files)

**1. middleware.ts** (project root)

```typescript
import { floatMiddleware } from 'floatprompt/next-dynamic'

export const middleware = floatMiddleware

export const config = {
  matcher: [
    // Match all paths except static files and images
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```

**2. src/app/api/float/route.ts**

```typescript
import { floatHandler } from 'floatprompt/next-dynamic'

export const GET = floatHandler

// Optional: Run on edge for lower latency
// export const runtime = 'edge'
```

**Result:**

```
https://example.com/about       → HTML page
https://example.com/about.md    → Markdown
https://example.com/blog/post   → HTML page
https://example.com/blog/post.md → Markdown
```

---

### Custom Configuration

```typescript
// middleware.ts
import { createFloatMiddleware } from 'floatprompt/next-dynamic'

export const middleware = createFloatMiddleware({
  exclude: [
    '/api/*',        // All API routes
    '/_next/*',      // Next.js internals
    '/admin',        // Admin section
    '/apply',        // Sensitive forms
    '/join',         // Checkout flow
    '/account/*',    // User account pages
  ],
})

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
}
```

```typescript
// src/app/api/float/route.ts
import { createFloatHandler } from 'floatprompt/next-dynamic'

export const GET = createFloatHandler({
  baseUrl: 'https://example.com',
  cacheControl: 'public, s-maxage=7200, stale-while-revalidate=86400',
  includeSchema: false, // Don't include JSON-LD in frontmatter
})

export const runtime = 'edge'
```

---

### With Existing Middleware

```typescript
// middleware.ts
import { NextRequest, NextResponse } from 'next/server'
import { composeWithFloat } from 'floatprompt/next-dynamic'

function myMiddleware(request: NextRequest) {
  // Your existing auth checks, redirects, etc.
  const isAuthenticated = checkAuth(request)

  if (!isAuthenticated && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  return NextResponse.next()
}

// Compose: FloatPrompt handles .md, your middleware handles everything else
export const middleware = composeWithFloat(myMiddleware, {
  exclude: ['/api/*', '/_next/*', '/login', '/dashboard/*'],
})

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
}
```

---

### Custom HTML Fetching (Authentication)

For pages that require authentication or special handling:

```typescript
// src/app/api/float/route.ts
import { createFloatHandler } from 'floatprompt/next-dynamic'
import { cookies } from 'next/headers'

export const GET = createFloatHandler({
  fetchHtml: async (url, request) => {
    // Get auth token from cookies
    const cookieStore = cookies()
    const authToken = cookieStore.get('auth-token')?.value

    const response = await fetch(url, {
      headers: {
        'Authorization': authToken ? `Bearer ${authToken}` : '',
        'Cookie': request.headers.get('cookie') || '',
        'x-floatprompt-internal': '1',
      },
    })

    if (!response.ok) return null
    return response.text()
  },
})
```

---

## URL Pattern Handling

### Supported Patterns

| Request | Resolves To | Notes |
|---------|-------------|-------|
| `/about.md` | `/about` | Standard page |
| `/blog/post.md` | `/blog/post` | Nested path |
| `/blog/my-slug.md` | `/blog/my-slug` | Dynamic routes work |
| `/index.md` | `/` | Homepage |
| `/.md` | `/` | Homepage (alt) |
| `/about/.md` | `/about` | Trailing slash variant |
| `/docs/api/index.md` | `/docs/api` | Nested index |

### Dynamic Routes

Dynamic routes (`/blog/[slug]`, `/docs/[...path]`) work automatically. The middleware doesn't need to know about your route structure — it just transforms the URL and lets Next.js handle routing.

```
/blog/my-awesome-post.md → /api/float?path=/blog/my-awesome-post
                         → fetches /blog/my-awesome-post
                         → Next.js routes to /blog/[slug]
                         → returns markdown
```

---

## Framework Compatibility

### Next.js

Works with **Next.js 13+** (App Router). Tested through Next.js 15.

No version-specific code needed — the middleware API has been stable since Next.js 13.

### Vercel

Works on all Vercel deployments (production, preview, development). The internal fetch handles Vercel's routing correctly.

**Recommendation:** Use Edge runtime for lower latency on marketing sites.

---

## Edge Runtime Compatibility

All FloatPrompt dependencies are Edge-compatible:

| Dependency | Edge Compatible | Notes |
|------------|-----------------|-------|
| `linkedom` | Yes | Pure JS DOM implementation |
| `@mozilla/readability` | Yes | Pure JS |
| `turndown` | Yes | Pure JS |
| `dompurify` | Yes | Works with linkedom |

Enable Edge runtime for lower latency:

```typescript
// src/app/api/float/route.ts
export const runtime = 'edge'
export const GET = floatHandler
```

---

## Caching Strategy

### Default Behavior

```typescript
'public, s-maxage=3600, stale-while-revalidate=86400'
```

- **CDN caches for 1 hour** (`s-maxage=3600`)
- **Serves stale while revalidating for 24 hours** — fast responses even when cache expires
- **Subsequent requests are instant** from CDN edge

### Custom Cache Times

```typescript
createFloatHandler({
  cacheControl: 'public, s-maxage=86400', // Cache for 24 hours
})
```

### Per-Path Caching

For fine-grained control, implement a custom handler:

```typescript
// src/app/api/float/route.ts
import { NextRequest } from 'next/server'
import { FloatPrompt } from 'floatprompt'

export async function GET(request: NextRequest) {
  const path = request.nextUrl.searchParams.get('path') || '/'

  // Fetch and extract (simplified)
  const html = await fetch(new URL(path, request.nextUrl.origin)).then(r => r.text())
  const result = FloatPrompt.extract(html, { url: path })

  if (!result) {
    return new Response('Not found', { status: 404 })
  }

  // Custom cache times based on path
  let cacheTime = 3600 // Default: 1 hour
  if (path === '/') cacheTime = 300 // Homepage: 5 minutes
  if (path.startsWith('/docs/')) cacheTime = 86400 // Docs: 24 hours
  if (path.startsWith('/blog/')) cacheTime = 604800 // Blog: 1 week

  return new Response(result.markdown, {
    headers: {
      'Content-Type': 'text/markdown; charset=utf-8',
      'Cache-Control': `public, s-maxage=${cacheTime}`,
    },
  })
}
```

---

## Security Considerations

### 1. Automatic `noindex` Detection

Pages with `<meta name="robots" content="noindex">` are **automatically excluded**. The handler checks for this meta tag and returns 404 if present.

This means:
- Pages you've already marked as hidden from search engines won't get `.md` versions
- No extra configuration needed for noindex pages
- Respects existing robots directives

### 2. Exclude Sensitive Paths

For additional protection, manually exclude pages that contain sensitive information or forms:

```typescript
createFloatMiddleware({
  exclude: [
    '/api/*',           // API routes
    '/_next/*',         // Next.js internals
    '/admin/*',         // Admin pages
    '/dashboard/*',     // User dashboards
    '/account/*',       // Account settings
    '/apply',           // Application forms
    '/join',            // Checkout/payment
    '/login',           // Auth pages
    '/signup',
  ],
})
```

### 3. Infinite Loop Prevention

The implementation uses `x-floatprompt-internal` header to prevent loops:

1. Middleware checks for header → skips processing if present
2. Handler adds header when fetching HTML → middleware won't intercept
3. Result: Clean request flow without recursion

### 4. Rate Limiting

Consider rate limiting the `/api/float` endpoint:

```typescript
// Using Vercel KV + Upstash Ratelimit
import { Ratelimit } from '@upstash/ratelimit'
import { kv } from '@vercel/kv'

const ratelimit = new Ratelimit({
  redis: kv,
  limiter: Ratelimit.slidingWindow(10, '10 s'), // 10 requests per 10 seconds
})

export async function GET(request: NextRequest) {
  const ip = request.ip ?? '127.0.0.1'
  const { success } = await ratelimit.limit(ip)

  if (!success) {
    return new Response('Rate limited', { status: 429 })
  }

  // ... rest of handler
}
```

### 5. CORS (Optional)

If you want to allow cross-origin requests to `.md` URLs:

```typescript
export async function GET(request: NextRequest) {
  const response = await floatHandler(request)

  // Add CORS headers
  response.headers.set('Access-Control-Allow-Origin', '*')
  response.headers.set('Access-Control-Allow-Methods', 'GET')

  return response
}
```

---

## Comparison: Build-Time vs Runtime

| Aspect | Build-Time (`/next`) | Runtime (`/next-dynamic`) |
|--------|----------------------|---------------------------|
| **When extraction runs** | Once at build | Per request (cached) |
| **Works with SSR** | No | Yes |
| **Works with API routes** | No | Yes |
| **Works with auth pages** | N/A | Yes (with custom fetcher) |
| **Dynamic routes** | Must know at build | Automatic |
| **First request latency** | Zero (pre-generated) | ~50-200ms (Edge) |
| **Subsequent requests** | Zero | Zero (CDN cached) |
| **Content freshness** | Stale until rebuild | Always current (or cached) |
| **Hosting requirements** | Static hosting | Serverless/Edge |

---

## README Updates

Add this section to the main README.md:

```markdown
## Dynamic Mode (SSR Sites)

For server-rendered Next.js sites that can't use static export:

### Quick Start

1. Install:
   ```bash
   npm install floatprompt
   ```

2. Add middleware (`middleware.ts`):
   ```typescript
   import { floatMiddleware } from 'floatprompt/next-dynamic'
   export const middleware = floatMiddleware
   export const config = {
     matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
   }
   ```

3. Add API route (`app/api/float/route.ts`):
   ```typescript
   import { floatHandler } from 'floatprompt/next-dynamic'
   export const GET = floatHandler
   ```

Now any page is available as markdown by adding `.md`:
- `/about` → `/about.md`
- `/blog/post` → `/blog/post.md`

See [Runtime Mode Documentation](./docs/runtime-mode.md) for advanced configuration.
```

---

## Testing Checklist

### General Tests

Before releasing, verify:

- [ ] `/about.md` returns markdown for `/about`
- [ ] `/index.md` returns markdown for `/`
- [ ] `/.md` returns markdown for `/`
- [ ] `/blog/my-post.md` works with dynamic routes
- [ ] `/about/.md` normalizes correctly
- [ ] Excluded paths return 404 or pass through
- [ ] Pages with `noindex` meta tag return 404
- [ ] Internal header prevents infinite loops
- [ ] Cookies are forwarded for authenticated pages
- [ ] Cache headers are set correctly
- [ ] Edge runtime works
- [ ] Composition with existing middleware works
- [ ] Error responses have correct status codes
- [ ] Large pages don't timeout
- [ ] Custom `apiRoute` configuration works
- [ ] Custom `contentType` configuration works

### Shift Nudge-Specific Tests

- [ ] `/curriculum.md` extracts all 85 lessons correctly
- [ ] `/faq.md` extracts all FAQ items
- [ ] `/reviews.md` extracts testimonials
- [ ] `/schedules/8.md` works (dynamic route)
- [ ] `/apply.md` returns 404 (excluded)
- [ ] `/join.md` returns 404 (excluded)
- [ ] `/welcome/team.md` returns 404 (excluded)
- [ ] Homepage markdown includes enrollment state text
- [ ] JSON-LD schemas appear in frontmatter
- [ ] Company logos section is extracted as text/links
- [ ] No infinite loops on any page
- [ ] Works on Vercel preview deployment
- [ ] Works on production (shiftnudge.com)

---

## Summary

The gap between FloatPrompt and modern SSR sites is a **delivery mechanism problem**, not a core extraction problem. The solution:

1. **Keep the existing build-time mode** for static sites
2. **Add a runtime mode** (`/next-dynamic`) for SSR sites
3. **Same core extraction logic** powers both modes

### Files to Add

| File | Lines | Purpose |
|------|-------|---------|
| `src/integrations/next-dynamic.ts` | ~220 | Middleware + handler + composition helper |

### Files to Modify

| File | Changes |
|------|---------|
| `package.json` | Add `./next-dynamic` export, add `next` peer dependency |
| `README.md` | Add "Dynamic Mode (SSR Sites)" section |

### API Surface

```typescript
// Exports from 'floatprompt/next-dynamic'
export { createFloatMiddleware, floatMiddleware }  // Middleware
export { createFloatHandler, floatHandler }        // API route handler
export { composeWithFloat }                        // Middleware composition
```

### Configuration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `baseUrl` | string | auto | Site URL for frontmatter |
| `exclude` | string[] | `['/api/*', ...]` | Paths to skip |
| `apiRoute` | string | `/api/float` | API route path |
| `cacheControl` | string | `public, s-maxage=3600...` | Cache headers |
| `contentType` | string | `text/markdown; charset=utf-8` | Response content type |
| `includeSchema` | boolean | `true` | Include JSON-LD in frontmatter |
| `fetchHtml` | function | internal | Custom HTML fetcher |

### Total Effort

- **~220 lines** of TypeScript
- **~50 lines** of README additions
- **~5 lines** of package.json changes
- **Production-ready** for Shift Nudge and similar sites
