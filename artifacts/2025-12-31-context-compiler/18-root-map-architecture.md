---
title: Root Map Architecture
type: architecture
created: 2025-12-31

human_author: @mds
human_intent: Define the root map as THE lily pad — one landing zone, scoped agent launches

ai_model: Claude Opus 4.5
ai_notes: Critical constraint — context is finite, traversal costs tokens, root map must be the single source of navigation
---

# Root Map Architecture

**The root map is the one lily pad that matters.**

---

## The Problem

AI context is finite. Every file read costs tokens. Every traversal hop loses momentum.

```
[Read 1] → [Read 2] → [Read 3] → [Read 4] → ... → [Context Lost]
  100%       85%        70%        50%              0%
```

Traditional hierarchical navigation:
```
root → src → auth → providers → config → [exhausted]
```

This is **exponential context drain**.

---

## The Solution

**One lily pad. Scoped agent launches. No traversal chains.**

```
root/map.md (THE lily pad)
    │
    │  AI lands here ONCE
    │  Gets full project terrain
    │  Decides where to send agents
    │
    └── Agent launches (fresh context each)
            │
            ├── Agent → src/auth/ (reads auth/map.md only)
            ├── Agent → src/api/ (reads api/map.md only)
            └── Agent → lib/ (reads lib/map.md only)
```

Each agent gets:
- Fresh context window
- Scoped map (its folder only)
- No inheritance from parent traversal

---

## The Constraints

| Constraint | Limit | Rationale |
|------------|-------|-----------|
| Line items in root map | **≤30** | Scannable in one read |
| Characters per line item | **≤80** | One-glance comprehension |
| Depth before agent launch | **1 hop** | Root → target, no intermediate |
| Maps an agent reads | **1-2** | Its local scope only |
| Total files before "lost" | **~15-20** | Working memory ceiling |

---

## Root Map Shape

The root map is **mechanically generated**. Code scans folders, outputs table. Zero AI effort.

```markdown
# Project Map

*Generated: 2025-12-31 | 23 folders | 156 files*

| Folder | Purpose | Go Here For |
|--------|---------|-------------|
| src/auth/ | Authentication | Login, sessions, JWT |
| src/api/ | REST endpoints | Routes, handlers |
| src/lib/ | Shared utilities | Helpers, constants |
| src/ui/ | React components | Buttons, forms, layouts |
| config/ | Configuration | Env vars, settings |
| scripts/ | Build scripts | CI, deployment |

## Quick Answers
- Auth questions → src/auth/
- API questions → src/api/
- Build questions → scripts/
- UI questions → src/ui/
```

**That's it.** 30 lines max. AI reads once, knows where to go.

---

## The Formula

**Correct (linear):**
```
Total context cost = root_map + (agent × local_map)
```

**Wrong (exponential):**
```
Total context cost = root + child + grandchild + ...
```

---

## Agent Launch Pattern

When AI needs depth:

```
1. AI reads root/map.md (one read)
2. AI identifies target: "auth questions → src/auth/"
3. AI launches agent with scope: src/auth/
4. Agent reads src/auth/map.md (fresh context)
5. Agent works within scope
6. Agent returns findings
7. Orchestrator synthesizes (without reading agent's files)
```

The orchestrator never traverses into child folders. It **delegates**.

---

## What This Means

### Root Map Responsibilities
- [ ] List ALL top-level folders
- [ ] One-line purpose for each
- [ ] "Go here for X" quick answers
- [ ] Generated by code, not AI

### Root Map Does NOT
- [ ] Contain deep context
- [ ] Require reading child maps
- [ ] Include decisions or rationale
- [ ] Need AI to maintain

### Local Maps (per folder)
- [ ] Self-contained for that scope
- [ ] Read by agents, not orchestrator
- [ ] Can have full trifecta (map/decisions/context)
- [ ] Don't reference parent maps

---

## The Lily Pad Mental Model

```
        ┌─────────────────────────────────┐
        │          ROOT MAP               │
        │    (the one lily pad)           │
        │                                 │
        │  AI lands here, sees terrain,   │
        │  launches agents to targets     │
        └──────────────┬──────────────────┘
                       │
         ┌─────────────┼─────────────┐
         ▼             ▼             ▼
    ┌─────────┐   ┌─────────┐   ┌─────────┐
    │ Agent 1 │   │ Agent 2 │   │ Agent 3 │
    │ auth/   │   │ api/    │   │ lib/    │
    │         │   │         │   │         │
    │ Fresh   │   │ Fresh   │   │ Fresh   │
    │ context │   │ context │   │ context │
    └─────────┘   └─────────┘   └─────────┘
```

No traversal chains. No context inheritance. No exponential drain.

---

## Why Generated?

The root map must be:

1. **Accurate** — Matches actual filesystem
2. **Current** — Updates when folders change
3. **Cheap** — Costs AI nothing to create
4. **Immutable** — Reflects reality, not interpretation

This is the definition of "mechanically generated":
- Code scans folders
- Code outputs markdown table
- AI reads result
- AI never maintains it

---

## Integration with Trifecta

```
project/
├── map.md              ← ROOT (generated, ≤30 lines)
├── decisions.md        ← Project-level decisions only
├── context.md          ← Project-level context only
│
├── src/
│   ├── auth/
│   │   ├── map.md      ← Local map (for agents)
│   │   ├── decisions.md
│   │   └── context.md
│   │
│   └── api/
│       ├── map.md      ← Local map (for agents)
│       ├── decisions.md
│       └── context.md
```

Root trifecta = project level only.
Local trifectas = scoped, read by agents.

---

## Breadcrumb Note

This captures the critical constraint: **context is finite**.

The root map architecture ensures:
1. One landing zone (root map)
2. Scoped agent launches (no traversal)
3. Fresh context per agent (no inheritance)
4. Mechanical generation (no AI maintenance cost)

The lily pad is the root map. Everything else is agent territory.
